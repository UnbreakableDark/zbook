    ES Module    
古老的模块系统:AMD CommonJS UMD
    
    一个模块就是一个文件，一个脚本就是一个模块。
模块可以互相加载，并可以使用  import export 来交换功能，从另外一个模块调用函数
export : 关键字标记了可以从当前模块外部访问的变量和函数。
import : 关键字允许从其他模块导入功能。

    由于模块支持特殊的关键字和功能，因此我们必须通过使用 <script type="module"> 
特性（attribute）来告诉浏览器，此脚本应该被当作模块（module）来对待。
浏览器会自动获取并解析（evaluate）导入的模块（如果需要，还可以分析该模块的导入），然后运行该脚本。
    模块只通过 HTTP(s) 工作，而非本地.
    模块级作用域：每个模块都有自己的顶级作用域。
换句话说，一个模块中的顶级作用域变量和函数在其他脚本中是不可见的。
    在浏览器中，对于HTML页面，每一个<script type="module">都存在独立的顶级作用域。
    模块代码仅在第一次导入时被解析。
如果同一个模块被导入到多个其他位置，那么它的代码只会执行一次，即在第一次被导入的时候。
然后将其导出（export）的内容提供给进一步的导入（importer）。

    规则：顶层模块代码应该用于初始化，创建模块特定的内部数据结构。
如果我们需要多次调用某些东西，我们应该将其以函数的形式导出。

    import.meta对象包含关于当前模块的信息。
它的内容取决于其所在的环境，在浏览器中，它包含了当前脚本的URL，或者它在HTML中，则是当前页面的URL。
    在一个模块中，顶级this是undefined。非模块脚本的顶级 this 是全局对象。
模块脚本是被延迟的，所以要等到 HTML 文档被处理完成才会执行它。
而常规脚本则会立即运行，所以我们会先看到常规脚本的输出。




    导入和导出
    export {x as y}
    export default
    import {x as y} from module

    动态导入
    import(module):加载模块并返回一个 promise，该 promise resolve 为一个包含其所有导出的模块对象。
