// let const var

//代码块： 如果在代码块 {...} 内声明的变量，那么这个变量只在该代码块内可见
{
    let message="hello world";//代码块外不可见
    //我们可以使用它来隔离一段代码，该段代码执行自己的任务，并使用仅属于自己的变量。
    //如果使用let对已经存在的变量进行重复声明，如果对应的变量没有单独的代码块，则会出现错误。
    //对于if，for，while等，在代码块内部中声明的变量也仅在内部可见。
    //for(let i=0;;){}
}

/*
    嵌套函数
    如果一个函数是在，另一个函数中创建的，该函数就被称为嵌套函数
*/
function makeCounter(){
    let count=0;
    return function(){
        return count++;
    }
}
let counter120=new makeCounter();
counter120();//0
counter120();//1
counter120();//2
//也就是调用时  记住的是外部词法环境[makeCounter]的count属性。
//在变量所在的词法环境中更新变量。


/*
    词法环境
    一、变量
    在JS中，每个运行的函数,代码块{},以及整个脚本。
    都有一个被称为词法环境（Lexical Environment）的内部(隐藏)的关联对象。
    词法环境对象由两部分组成：
1.环境记录（Environment Record）
    一个存储所有局部变量作为其属性(包括一些其他信息，例如this的值)的对象。
2.对外部词法环境的引用,与外部代码相关联。

    一个变量只是环境记录这个特殊的内部对象的一个属性。
获取或修改变量  意味着 获取或修改词法环境的一个属性
    

    词法环境是一个规范对象(specification object)：它只存在于语言规范的理论层面。
用于描述事物是如何工作的。我们无法在代码中获取该对象并直接对其进行操作。

    1.当脚本开始运行，词法环境预先填充了所有声明的变量。
最初，他们处于 未初始化（Uninitialized）状态。这是一种特殊的内部状态，
这意味着引擎知道变量。但是在let声明前，不能引用它。几乎就像变量不存在一样。
    2.然后let定义出现，它尚未赋值，因此它的值为  undefined.从这一刻起，我们就可以使用变量了。

    变量是特殊内部对象的属性，与当前正在执行的(代码)块/函数/脚本有关。
    操作变量实际上是操作该对象的属性。

    二、函数声明
    一个函数其实也是一个值，就像一个变量一样。不同之处在于函数声明的初始化会被立即完成。
当创建一个词法环境(Lexical Environment)时，函数声明会立即变为即用函数。
而不是像let那样直到声明处才可用。
这就是为什么可以在声明自身之前调用一个以函数声明(Function Declaration)的方式声明的函数。

    三、内部和外部的词法环境
    在一个函数运行时，在刚调用开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。
    当代码要访问一个变量时，首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推。
直到全局词法环境。
    如果在任何地方都找不到这个变量，那么严格模式下就会报错。
（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）

    四、返回函数
    在每次函数调用的开始，都会创建一个新的词法环境对象，以存储该函数运行时的变量。
    所有的函数在"诞生"时都会记住创建它们的词法环境。从技术上讲，这不是魔法：
所有函数都有名为[Environment]的隐藏属性，该属性保存了对创建该函数的词法环境的引用。
    在变量所在的词法环境中更新变量
*/

/*
    闭包
    闭包是指一个函数可以记住其外部变量并可以访问这些变量。在某些编程语言中，这是不可能的，
或者应该以一种特殊的方式编写函数来实现。
    JS中，所有的函数都是天生闭包的。（只有一个例外  new Function 语法）
    
*/